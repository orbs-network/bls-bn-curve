/*

Ganache mnemonic for account generation:
decorate provide ritual swarm will inmate sausage lab banana daring trash liar

Not using web3 1.0.0 beta because its docs are not as good as 0.20.x

*/


const ETH_URL = "http://127.0.0.1:7545";
const CONTRACT_ADDRESS = '0xF7d58983Dbe1c84E03a789A8A2274118CC29b5da';
const DEPOSIT_WEI = 1000000000000000000; // 1e18

const CLIENTS = [{
        address: '0x6E0C57E9B3a8BfDe94e89105b78A7f8bc40e85A0',
        privateKey: 'a05e8bd12f53f6063feae2623273cca6f0747574c3101537ea1f5602737dc97e'
    },
    {
        address: '0xc761554c5EBE2303163fdb8319c0bA5b6bAB6526',
        privateKey: '9f47537b57875335b059ad59ce1c4a02b2504158ee8df36879ef44723f364deb'
    },
    {
        address: '0xa9C4381A5f6f9C7B8d525696436184B5f8763154',
        privateKey: '16b92ef93d268d20ec5078ef17b35605e7ba800a198b6916fbdc86bfced6f060'
    },
    {
        address: '0xA590aB8FFfb627C78c1632Ea986115f0c5d9f3bd',
        privateKey: 'ebf09917aac97a881851b828ce4e3e45d7fb7071577456ea932b17ec0fa04507'
    },
    {
        address: '0x501106e7c52dBe89A8a67378A17586649E053C25',
        privateKey: '4fd18d7b4d391ffede4d2f7691de47252be47bda95f10bcfe7ee399d181a8723'
    }
]

fs = require('fs');

const assert = require('assert');
const Web3 = require('web3');
const solc = require('solc')

const web3 = new Web3(new Web3.providers.HttpProvider(ETH_URL));
const mocha = require('mocha').mocha;
const CLIENT_COUNT = 5;
const THRESHOLD = 2;
// let myContract;
var input = {
    'dkg.sol': fs.readFileSync('./test/dkg.sol', 'utf8')
};
let compiledContract = solc.compile({
    sources: input
}, 1);
let abi = compiledContract.contracts['dkg.sol:dkg'].interface;
let bytecode = '0x' + compiledContract.contracts['dkg.sol:dkg'].bytecode;
// let gasEstimate = web3.eth.estimateGas({
//     data: bytecode
// });
let DKG = web3.eth.contract(JSON.parse(abi));

var myContract = DKG.new(THRESHOLD, CLIENT_COUNT, DEPOSIT_WEI, {
    data: bytecode,
    gas: 3000000,
    from: CLIENTS[0].address
});

// var dkg = DKG.new(THRESHOLD, CLIENT_COUNT, DEPOSIT_WEI, {
//     from: CLIENTS[0].address,
//     data: bytecode,
//     gas: 2000000
// }, function (err, myContract) {
//     if (!err) {
//         if (!myContract.address) {
//             console.log(myContract.transactionHash)
//         } else {
//             console.log(myContract.address)
//         }
//     }
// });

// const contractSol = fs.readFileSync('./test/dkg.sol'); // Not used now
// const contractAbi = fs.readFileSync('./test/dkg.abi');
// const Contract = web3.eth.contract(contractAbi);
// const myContract = Contract.at(CONTRACT_ADDRESS);
// let myContract;
// var compiled = web3.eth.compile.solidity(contractSol);
// var code = compiled.code;
// // contract json abi, this is autogenerated using solc CLI
// var abi = compiled.info.abiDefinition;
// web3.eth.contract(abi).new({
//     data: code
// }, function (err, contract) {
//     if (err) {
//         console.error(err);
//         return;
//         // callback fires twice, we only want the second call when the contract is deployed
//     } else if (contract.address) {
//         myContract = contract;
//     }
// });


describe('DKG Contract Tests', async () => {

    // before(() => {
    //     const Contract = web3.eth.contract(contractAbi);
    //     myContract = Contract.at(CONTRACT_ADDRESS);
    // });
    it('runs join()', async () => {
        try {
            await joinAllClients();
            assert(true);
        } catch (e) {
            console.log(`Join() Error: ${e.msg} ${JSON.stringify(e)}`);
            assert(false);
        }
    });
    it('runs commit()', async () => {
        try {
            await commitAllClients();
            assert(true);
        } catch (e) {
            console.log(`Commit() Error: ${e.msg} ${JSON.stringify(e)}`);
            assert(false);
        }
    });
    it('runs signAndVerify()', async () => {
        try {
            await signAndVerify();
            assert(true);
        } catch (e) {
            console.log(`SignAndVerify() Error: ${e.msg} ${JSON.stringify(e)}`);
            assert(false);
        }
    });
});

/// Join

function joinAllClients() {
    console.log(` =====> join <=====`);
    const promises = [];
    CLIENTS.forEach((client, i) => {
        console.log(`Calling join() with client #${i} ${client.address}`);
        promises.push(join(client, i));
    });
    promises.push(() => {
        setTimeout(1000);
    });
    return Promise.all(promises);
}


function join(client, i) {
    return new Promise((resolve, reject) => {
        if (!myContract.join) {
            reject('No join() method on contract!');
        }
        myContract.join({
            from: client.address,
            value: DEPOSIT_WEI,
            gasLimit: 3000000
        }, (err, result) => {
            if (err !== null) {
                console.log(`Failed to join() with client #${i} ${client.address}. msg=${err.msg} Err=${JSON.stringify(err)}`);
                return reject(err);
            }
            console.log(`Client #${i} ${client.address} joined successfully. Result: ${result}`);
            client.id = result;
            resolve(result);
        });
    });
}


/// Commit

function commitAllClients() {
    console.log(` =====> commit <=====`);
    const promises = [];
    CLIENTS.forEach((client, i) => {
        console.log(`Calling commit() with client #${i} ${client.address}`);
        promises.push(commit(client, i));
    });
    promises.push(() => {
        setTimeout(1000);
    });
    return Promise.all(promises);
}

function commit(client, i) {
    return new Promise((resolve, reject) => {
        const pubCommit = getPubCommit();
        const prCommit = getPrCommit();
        if (!myContract.commit) {
            reject('No commit() method on contract!');
        }
        if (!client.id) {
            reject(`Missing client id for client #${i}. Client id is the result of join(). Did join() finished correctly?`);
        }

        console.log(`Commit(): client.id=${client.id} pubCommit=${JSON.stringify(pubCommit)} prCommit=${JSON.stringify(prCommit)}`);

        myContract.commit(client.id, pubCommit, prCommit, {
            from: client.address,
            gasLimit: 3000000
        }, (err, result) => {
            if (err !== null) {
                console.log(`Commit(): Failed to commit() with client #${i} ${client.address}. msg=${err.msg} Err=${JSON.stringify(err)}`);
                return reject(err);
            }
            console.log(`Commit(): Client #${i} ${client.address} committed successfully. Result: ${result}`);
            client.id = result;
            resolve(result);
        });
    });
}


function signAndVerify() {
    return true;
}

// This should call Go code - it is just a mock here
function getPubCommit() {

    const SOME_BIG_NUMBER = '0xfc9e0eefe9f3a5101b7c025b217c03c95dbf9bb4f2d1d46db238e305af104103';
    const res = [];
    const pubCommitLength = THRESHOLD * 2 + 2;
    for (let i = 0; i < pubCommitLength; i++) {
        res.push(web3.toBigNumber(SOME_BIG_NUMBER));
    }
    return res;
}

// This should call Go code - it is just a mock here
function getPrCommit() {
    const ANOTHER_BIG_NUMBER = '0xfc9e0eefe9f3a5101b7c025b217c03c95dbf9bb4f2d1d46db238e305af104104';
    const res = [];
    const prCommitLength = CLIENT_COUNT;
    for (let i = 0; i < prCommitLength; i++) {
        res.push(web3.toBigNumber(ANOTHER_BIG_NUMBER));
    }
    return res;
}